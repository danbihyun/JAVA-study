# 07. 상속

## 07-1. 상속

**상속**

- 부모 클래스의 필드와 메소드를 자식 클래스에서 사용할 수 있도록 하는 것.  
  상속은 extends 키워드로 선언하며, 자바에서는 단일 상속만 허용한다.

**메소드 재정의**

- 부모 메소드를 자식 클래스에서 다시 정의하는 것.  
  재정의 조건: 메소드 이름, 매개변수 타입/개수, 리턴 타입이 모두 동일할 것.

**final 클래스**

- final 키워드로 선언된 클래스는 부모 클래스로 사용할 수 없는 final 클래스이다.  
  예를 들어 String, Math, Integer

**final 메소드**

- final 키워드로 선언된 메소드는 자식 클래스에서 재정의할 수 없는 final 메소드이다. (단, 오버로딩은 가능)  
  주로 핵심 로직을 보호할 때 사용된다.

## 07-2. 타입 변환과 다형성

**클래스 타입 변환**

- 다른 클래스 타입으로 객체를 대입하는 것.

**자동 타입 변환**

- 자식 객체를 부모 타입 변수에 대입할 때에는 자동으로 타입이 변환된다.

**강제 타입 변환**

- 자식 객체가 부모 타입으로 변환된 상태에서 다시 원래의 자식 타입으로 변환하고자 할 때 캐스팅() 연산자를 사용하여 강제로 타입 변환을 할 수 있다.

**instanceof 연산자**

- 객체가 어떤 타입인지 조사할 때 instanceof 연산자를 사용한다.  
  주로 강제 타입 변환 전에 변환이 가능한지 조사할 때 사용한다.

**다형성**

- 객체 사용 방법은 동일하지만 실행결과가 다양하게 나오는 성질을 말한다.  
  다형성을 구현하는 기술은 메소드 재정의와 타입 변환이다. 자식 객체가 재정의된 메소드를 가지고 있을 경우, 부모 타입으로 자동 타입 변환 후에 메소드를 호출하면 재정의된 자식 메소드가 호출 되면서 다양한 실행결과를 가져올 수 있다.

## 07-3. 추상 클래스

**추상 클래스**

- 클래스들의 공통적인 필드와 메소드를 추출해서 선언한 클래스를 말한다.  
  abstract 키워드로 선언하며, 인터페이스와 달리 필드(상태)를 가질 수 있다.

**추상 메소드**

- 추상 클래스에서만 선언할 수 있고, 메소드의 선언부만 있는 메소드를 말한다.  
  추상 메소드는 자식 클래스에서 재정의되어 실행 내용을 결정해야 한다.  
  선언부만 있고 구현부 {} 가 없다. → 끝에 ;로 끝난다. 또한 반드시 자식 클래스에서 오버라이딩 해야 한다.
  <br><br><br>

# 08. 인터페이스

## 08-1. 인터페이스

**인터페이스**

- 객체의 사용 방법을 정의한 타입. 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.  
  개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다. 구성 멤버는 상수 필드와 추상 메소드.

**상수 필드**

- 인터페이스의 상수 필드는 기본적으로 public static final 특성을 갖는다.  
  관례적으로 필드 이름은 모두 대문자로 작성해야 하며, 선언 시 초기값을 대입해야 한다.

**추상 메소드**

- 인터페이스에 선언된 메소드는 public abstract가 생략되고 메소드 선언부만 있는 추상 메소드이다.  
  구현 클래스는 반드시 추상 메소드를 재정의해야 한다.

**implements**

- 구현 클래스는 어떤 인터페이스로 사용 가능한지(어떤 인터페이스를 구현하고 있는지)를 기술하기 위해 클래스 선언 시 implements 키워드를 사용한다.

**인터페이스 사용**

- 클래스를 선언할 때 인터페이스는 필드, 생성자 또는 메소드의 매개 변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있다.

```
① 인터페이스가 필드 타입으로 사용될 경우: 필드에 구현 객체를 대입할 수 있다.
② 인터페이스가 생성자의 매개 변수 타입으로 사용될 경우: new 연산자로 객체를 생성할 때 구현 객체를 생성자의 매개값으로 대입할 수 있다.
③ 인터페이스가 로컬 변수 타입으로 사용될 경우: 변수에 구현 객체를 대입할 수 있다.
④ 인터페이스가 메소드의 매개 변수 타입으로 사용될 경우: 메소드 호출 시 구현 객체를 매개값으로 대입할 수 있다.

대입이 된 후에는 재정의된 구현 객체의 메소드를 호출할 수 있다.
```

## 08-2. 타입 변환과 다형성

**자동 타입 변환**

- 구현 객체가 인터페이스 변수에 대입되는 것.

**다형성**

- 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념상의 차이는 있지만, 모두 재정의와 타입 변환 기능을 제공한다는 점에서 둘 다 다형성을 구현하는 방법은 비슷하다고 할 수 있다.

**강제 타입 변환**

- 인터페이스에 대입된 구현 객체를 다시 원래 구현 클래스 타입으로 변환하는 것을 말한다.

**instanceof**

- 강제 타입 변환을 하기 전에 변환이 가능한지 조사할 때 사용한다.  
  상속에서는 자식 클래스 타입인지, 인터페이스에서는 구현 클래스 타입인지를 확인할 때 사용한다.

**인터페이스 상속**

- 클래스는 다중 상속을 허용하지 않지만, 인터페이스는 다중 상속을 허용한다.  
  즉 extends 키워드 뒤에 상위 인터페이스가 올 수 있다.
  <br><br><br>

# 09. 중첩 클래스와 중첩 인터페이스

## 09-1. 중첩 클래스와 중첩 인터페이스 소개

**중첩 클래스**

- 클래스 내부에 선언한 클래스를 말한다.  
  중첩 클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있고, 외부에는 불필요한 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.

**멤버 클래스**

- 클래스의 멤버로서 선언되는 중첩 클래스를 말한다.  
  멤버 클래스는 바깥 객체의 필요 여부에 따라 인스턴스 멤버 클래스와 정적 멤버 클래스로 구분한다.

**로컬 클래스**

- 생성자 또는 메소드 블록 내부에 선언된 중첩 클래스.

**중첩 인터페이스**

- 클래스의 멤버로 선언된 인터페이스.  
  중첩 인터페이스는 인스턴스 멤버 인터페이스와 정적 멤버 인터페이스 모두 가능하다. 주로 정적 멤버 인터페이스를 많이 사용하는데, UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다.

## 09-2. 익명 객체

**익명 자식 객체**

- 자식 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면 자식 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다. 이 경우 익명 자식 객체를 생성해서 사용하는 것이 좋은 방법이다.

```
<!-- 익명 자식 객체 생성 방법 -->

부모클래스 [필드|변수] = new 부모클래스(매개값, …) {
    <!-- 필드 -->
    <!-- 메소드 -->
};
```

**익명 구현 객체**

- 구현 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면 구현 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다. 이 경우 익명 구현 객체를 생성해서 사용하는 것이 좋은 방법이다.

```
<!-- 익명 구현 객체 생성 방법 -->

인터페이스 [필드|변수] = new 인터페이스() {
    <!-- 인터페이스에 선언된 추상 메소드의 실체 메소드 선언 -->
    <!-- 필드 -->
    <!-- 메소드 -->
};
```
